/**
 * @class ModelLoader
 * @imports System
 * @imports Logger
 * 
 * @copyright Jay Tang 2012
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */

//@private
function initClass() {
	this._callbacks = [];
	this._busyCount = 0;
	this._pendingCount = 0;
	this._pendingFlush = [];
	this._holder = {};
}

//@static
function find(key, positive) {
	if (!key) return;
	var source = getSource(key, this);
	if (source) {
		if (!source.error) {
			return source.object;
		} else {
			var msg = $logger.error("model ${0}#${1} was not loaded: ${2}", source.$class.getName(), key, source.error);
			if (positive) {
				System.throwError(msg);
			}
		}
	}
}

//@static
function load(key, callback) {
	if (!key || getSource(key, this)) return;
	var source = putSource(initSource.call(this, key));
	call.call(this, source, callback);
}

//@protected
function call(source, callback) {
	try {
		_pendingCount++;
		$logger.debug("request to load model ${0}#${1}", source.$class.getName(), source.key);
		System.loadback(source, handleSource);
	} catch (ex) {
		_pendingCount--;
		source.error = ex.message;
		$logger.error("failed to load model ${0}#${1}: ${2}", source.$class.getName(), source.key, ex.message);
	} finally {
		if (callback) waitFor(System.callback(notify, callback, source));
	}
}

//@private
function getHolder(clazz) {
	var name = clazz.getName();
	if (!_holder[name]) {
		_holder[name] = {};
	}
	return _holder[name];
}

//@private
function getSource(key, clazz) {
	return getHolder(clazz)[key];
}

//@private
function putSource(source) {
	getHolder(source.$class)[source.key] = source;
	return source;
}

//@private
function initSource(key) {
	var source = {};
	source.key = key;
	source.$class = this;
	source.type = this.$("model.type");
	source.base = this.$("model.base");
	source.module = this.$("model.module");
	source.path = this.getName().split(".").join("/").concat(".", source.type);
//	if (source.base.indexOf("file") != 0) source.path = source.path.concat("#", source.key);
	return source;
}

//@private
function waitFor(callback) {
	if (!callback) return;
	if (_pendingCount) {
		_callbacks.push(callback);
	} else {
		callback();
	}
}

//@private
function notify(callback, source) {
	callback(source.object);
}

//@private
function handleSource(source) {
	if (source.content) {
		$logger.debug("response for model ${0}#${1} from ${2}", source.$class.getName(), source.key, source.url);
		try {
			parseSource(source);
		} catch (ex) {
			source.error = ex.message;
			$logger.error("failed to parse model ${0}#${1}: ${2}", source.$class.getName(), source.key, ex.message);
		}
	} else {
		if (!source.error) source.error = "empty content";
		$logger.error("failed to load model ${0}#${1} from ${2}: ${3}", source.$class.getName(), source.key, source.url, source.error);
	}
	if (source.status < 100) {
		//error
	} else {
		_pendingCount--;
		flush();
	}
}

//@private
function parseSource(source) {
	source.contentType = source.type;
	switch (source.contentType) {
	case "json":
		source.content = System.parseJSONFromText(source.content);
		break;
	case "xml":
		source.content = System.parseJSONFromXML(source.content.documentElement);
		break;
	case "csv":
		source.content = System.parseCSV(source.content, source.$class.$("model.delimiter"));
		break;
	}
	_pendingFlush.push(source);
}

//@private
function flush() {
	for (var i = 0; i < _pendingFlush.length; i++) {
		if (_pendingCount) return;
		flush_parseModel(_pendingFlush[i]);
	}
	for (var i = 0; i < _pendingFlush.length; i++) {
		if (_pendingCount) return;
		flush_initModel(_pendingFlush[i]);
	}
	if (_busyCount) return;
	while (_callbacks.length) {
		if (_pendingCount) return;
		_callbacks.shift()();
	}
	for (var i = 0; i < _pendingFlush.length; ) {
		if (_pendingCount) return;
		if (_pendingFlush[i].flushStatus == 1) {
			_pendingFlush.splice(i, 1);
		} else i++;
	}
}

//@private
function flush_parseModel(source) {
	if (typeof source.flushStatus == "undefined") {
		source.flushStatus = "busy 0";
		_busyCount++;
		source.object = new source.$class(source.$class);
		if (source.$class.parseModel) {
			source.$class.parseModel.call(source.object, source.content);
		}
		_busyCount--;
		source.flushStatus = 0;
	}
}

//@private
function flush_initModel(source) {
	if (source.flushStatus == 0) {
		source.flushStatus = "busy 1";
		_busyCount++;
		if (source.$class.initModel) {
			source.$class.initModel.call(source.object, source.content);
		}
		_busyCount--;
		source.flushStatus = 1;
	}
}
