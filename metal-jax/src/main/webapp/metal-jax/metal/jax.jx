/**
 * @copyright Jay Tang 2012
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
(function() {
	
	(function() {
		
		var $setting = {
			bootClass: "",
			baseModule: "",
			baseContext: "base",
			crossDomain: "xd",
			crossTimeout: "3000",
			classType: "jx",
			faceType: "html"
		};
		var $source = {
			contentType: "context",
			name: "metal.jax.ClassLoader",
			scope: { $public:{}, $protected:{}, $static:{}, $imports:{}, $requires:{}, $resource:{}, $setting:$setting },
			setting: {
				source: [{ base:"${bootURL}", module:"${bootModule}", includes:"^metal.jax[.]" }],
				content: [
					{ type:"class",			"extends":"metal.jax.Object" },
					{ type:"context",		"extends":"metal.jax.Context" },
					{ type:"face",			"extends":"metal.jax.Face" },
					{ type:"${faceType}",	"extends":"metal.jax.Face" },
					{ type:"model",			"extends":"metal.jax.Model" },
					{ type:"service",		"extends":"metal.jax.Service" }
				]
			}
		};
		var _urlRE_ = /(?:([^\/:]+:\/\/[^\/]*)?([^?#]+)?)(?:\?([^#]+))?(?:#(.+))?/;
		
		function main() {
			parseSetting($setting);
			if (this[$setting["bootModule"]]) {
				$source.scope.$logger.info("metal-jax already loaded from '${bootURL}'", $setting);
			} else {
				this[$setting["bootModule"]] = {};
				waitFor("load", function() {
					$source.type = $setting["classType"];
					$source.base = $setting["bootURL"];
					$source.module = $setting["bootModule"];
					$source.path = $source.name.split(".").join("/").concat(".", $source.type);
					loadback($source, parseSource);
				});
			}
		}
		
		function parseSetting(setting) {
			var parts = _urlRE_.exec(this.document.URLUnencoded||this.document.URL);
			setting["baseOrigin"] = parts[1];
			setting["baseScheme"] = parts[1].split(":")[0];
			setting["baseURL"] = splitPath(parts[1] + parts[2], -1, -1);
			setting["baseModule"] = parts[3] || setting["baseModule"];
			setting["bootClass"] = parts[4] || setting["bootClass"];
			var nodes = this.document.getElementsByTagName("script");
			var parts = _urlRE_.exec(resolvePath(nodes[nodes.length-1].src, setting["baseURL"] + "/"));
			setting["bootOrigin"] = parts[1];
			setting["bootURL"] = splitPath(parts[1] + parts[2], -3, -3);
			setting["bootModule"] = splitPath(parts[2], -3, 1);
			setting["bootContext"] = splitPath(parts[2], -2, 2).split(".")[0].split("/").join(".");
			setting["baseModule"] = parts[3] || setting["baseModule"];
			setting["baseContext"] = parts[4] || setting["baseContext"];
		}
		
		function logSetting(logger, setting) {
			logger.info("metal.jax.init.bootModule", setting);
			logger.info("metal.jax.init.bootContext", setting);
			if (setting["baseModule"]) {
				logger.info("metal.jax.init.baseModule", setting);
			} else {
				logger.warn("metal.jax.init.baseModule.missing");
			}
			logger.info("metal.jax.init.baseContext", setting);
			logger.info("metal.jax.init.bootClass", setting);
		}
		
		function parseSource(source) {
			if (source.content) {
				$static.call(source);
				source.holder = {};
				source.holder[source.name] = source;
				source.scope.$private.$source = source;
				source.scope.$private.compile = $static;
				source.scope.$private.loadback = loadback;
				source.scope.$static.splitPath = splitPath;
				source.scope.$static.resolvePath = resolvePath;
				source.scope.initClass_();
				source.scope.waitFor(initContext);
			} else {
				throw Error("failed to load URL: " + source.url + ", error: " + source.error);
			}
		}
		
		function initContext() {
			$source.context.loadClass($setting["baseContext"], function() {
				var baseContext = $source.context.findClass($setting["baseContext"]);
				var context = baseContext ? baseContext.getContext() : $source.context;
				var Face = context.findClass("metal.jax.Face");
				Face && Face.parseModel.call($source.scope, this.document.body);
				context.loadClass($setting["bootClass"], function() {
					var bootClass = context.findClass($setting["bootClass"]);
					var rootFace = Face && new Face();
					Face && Face.initModel.call(rootFace, null, [this.document.body]);
					if (baseContext) {
						if (baseContext.main) {
							bootClass = baseContext;
						} else if (baseContext.extendsClass("metal.jax.Face")) {
							bootClass = baseContext;
						}
					}
					if (bootClass) {
						if (bootClass.main) {
							bootClass.main.call();
						} else if (bootClass.extendsClass("metal.jax.Face") && !this.document.body.firstChild) {
							rootFace = new bootClass(this.document.body);
						}
					}
				});
				logSetting($source.scope.$logger, $setting);
			});
		}
		
		function waitFor(event, callback) {
			if (this.addEventListener) {
				this.addEventListener(event, callback, false);
			} else if (this.attachEvent) {
				this.attachEvent("on"+event, callback);
			}
		}
		
		function loadback(source, callback) {
			var origin = _urlRE_.exec(source.base)[1];
			if (origin) {
				var action = (origin == $setting["baseOrigin"]) ? loadSameDomain : loadCrossDomain;
				action.call(this, source, callback);
			} else {
				throw Error("invalid URL: " + source.base);
			}
		}
		
		function loadSameDomain(source, callback) {
			var caller = this;
			var request = requestSameDomain(source, function() {
				if (!request || request.readyState != 4) return;
				if (request.status == 200 || request.status == 0) {
					source.content = request.responseText;
				} else {
					source.status = request.status;
					source.error = request.statusText;
				}
				callback.call(caller, source);
			});
			try {
				request.send(null);
			} catch (ex) {
				throw Error("failed to load URL: " + source.url + ", error: " + ex.message);
			}
		}
		
		function requestSameDomain(source, callback) {
			var request;
			if (typeof XMLHttpRequest != "undefined" && typeof ActiveXObject == "undefined") {
				request = new XMLHttpRequest();
			} else if (typeof XMLHttpRequest != "undefined" && typeof ActiveXObject != "undefined" && $setting["baseScheme"] != "file") {
				request = new XMLHttpRequest();
			} else if (typeof ActiveXObject != "undefined") {
				request = new ActiveXObject("Microsoft.XMLHTTP");
			} else {
				throw Error("XHR not supported");
			}
			source.url = [source.base, source.module, source.path].join("/");
			request.open("GET", source.url, true);
			request.onreadystatechange = callback;
			return request;
		}
		
		function loadCrossDomain(source, callback) {
			var caller = this;
			var request = requestCrossDomain(source, function(response) {
				if (arguments.length == 0) return;
				clearRequest(request);
				if (typeof response != "object") {
					source.error = "bad response";
				} else if (response.error) {
					source.error = response.error;
				} else {
					source.content = response.content;
				}
				callback.call(caller, source);
			});
			this.document.firstChild.firstChild.appendChild(request.node);
		}
		
		function requestCrossDomain(source, callback) {
			var request = {};
			request.url = source.url = [source.base, $setting["crossDomain"], source.module, source.path].join("/");
			this[$setting["bootModule"]][request.url] = callback;
			request.node = this.document.createElement("script");
			request.node.src = request.url;
			request.timeout = setInterval(callback, parseInt($setting["crossTimeout"]));
			return request;
		}
		
		function clearRequest(request) {
			delete this[$setting["bootModule"]][request.url];
			this.document.firstChild.firstChild.removeChild(request.node);
			clearInterval(request.timeout);
			delete request.node;
		}
		
		function resolvePath(path, base) {
			if (!_urlRE_.exec(path)[1]) {
				if (path.charAt(0) == "/") {
					path = _urlRE_.exec(base)[1].concat(path);
				} else {
					base = splitPath(base, -1, -1);
					path = base ? base.concat("/", path) : path;
				}
			}
			return path;
		}
		
		function splitPath(path, index, count, delim) {
			if (!path) return path;
			delim = delim || "/";
			var parts = path.split(delim);
			index = index>=0 ? index : parts.length+index;
			var keep = count <= 0;
			count = keep ? -count : count;
			var parts2 = parts.splice(index, count);
			return (keep ? parts : parts2).join(delim);
		}
		
		main();
		
	})();
	
	function $static() {
		this.scope.$private = this.scope;
		this.scope.$static.$static = this.scope.$static;
		this.scope.$static.$public = this.scope.$public;
		this.scope.$static.$protected = this.scope.$protected;
		this.scope.$protected.$static = this.scope.$static;
		this.scope.$protected.$public = this.scope.$public;
		this.scope.$protected.$protected = this.scope.$protected;
		with (this.scope.$static) {
			with (this.scope.$protected) {
				with (this.scope.$private) {
					try { eval(this.content); }
					finally { delete this.content; }
				}
			}
		}
	}
	
})();
