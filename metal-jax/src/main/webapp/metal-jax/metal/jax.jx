/**
 * @copyright Jay Tang 2012
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
(function() {
	
	(function() {
		
		var $setting = {
			mainClass: "",
			mainModule: "",
			mainContext: "main",
			crossDomain: "xd",
			crossInterval: "3000",
			classType: "jx",
			faceType: "html"
		};
		var $source = {
			name: "metal.jax.ClassLoader",
			contentType: "context",
			scope: { $public:{}, $protected:{}, $static:{}, $imports:{}, $setting:$setting },
			setting: {
				source: [{ base:"${bootURL}", module:"${bootModule}", includes:"^metal.jax[.]" }],
				content: [
					{ type:"class", "extends":"metal.jax.Object" },
					{ type:"context", "extends":"metal.jax.Context" },
					{ type:"model", "extends":"metal.jax.Model" },
					{ type:"face", "extends":"metal.jax.Face" },
					{ type:"${faceType}", "extends":"metal.jax.Face" }
				]
			}
		};
		var _urlRE_ = /(?:([^\/:]+:\/\/[^\/]*)?([^?#]+)?)(?:\?([^#]+))?(?:#(.+))?/;
		
		function main() {
			parseSetting($setting);
			if (!this[$setting["bootModule"]]) {
				this[$setting["bootModule"]] = {};
				waitFor("load", function() {
					$source.base = $setting["bootURL"];
					$source.module = $setting["bootModule"];
					$source.path = $source.name.split(".").join("/").concat(".", $setting["classType"]);
					loadback($source, parseSource);
				});
			}
		}
		
		function parseSetting(setting) {
			var parts = _urlRE_.exec(this.document.URLUnencoded||this.document.URL);
			setting["baseOrigin"] = parts[1];
			setting["baseScheme"] = parts[1].split(":")[0];
			setting["baseURL"] = splitPath(parts[1] + parts[2], -1, -1);
			setting["mainClass"] = parts[4] || setting["mainClass"];
			var nodes = this.document.getElementsByTagName("script");
			var parts = _urlRE_.exec(resolvePath(nodes[nodes.length-1].src, setting["baseURL"], true));
			setting["bootOrigin"] = parts[1];
			setting["bootURL"] = splitPath(parts[1] + parts[2], -3, -3);
			setting["bootModule"] = splitPath(parts[2], -3, 1);
			setting["bootContext"] = splitPath(parts[2], -2, 2).split(".")[0].split("/").join(".");
			setting["mainModule"] = parts[3] || setting["mainModule"];
			setting["mainContext"] = parts[4] || setting["mainContext"];
		}
		
		function parseSource(source) {
			if (source.content) {
				$static.call(source);
				source.holder = {};
				source.holder[source.name] = source;
				source.scope.$source = source;
				source.scope.compile = $static;
				source.scope.loadback = loadback;
				source.scope.$static.splitPath = splitPath;
				source.scope.$static.resolvePath = resolvePath;
				source.scope.initClass_();
				source.scope.waitFor(initContext);
			} else {
				throw Error("failed to load URL: " + source.url + ", error: " + source.error);
			}
		}
		
		function initContext() {
			$source.context.loadClass($setting["mainContext"], function() {
				var mainContext = $source.context.findClass($setting["mainContext"]);
				var context = mainContext ? mainContext.getContext() : $source.context;
				var Face = context.findClass("metal.jax.Face", true);
				var model = Face.parseModel.call($source.scope, this.document.body, true);
				context.loadClass($setting["mainClass"], function() {
					this[$setting["bootModule"]]["face"] = Face.newObject(model);
					var mainClass = context.findClass($setting["mainClass"]);
					if (mainContext) {
						if (mainContext.main) {
							mainContext.main.call();
						} else if (mainContext.extendsClass(Face)) {
							this.document.body.appendChild(new mainContext().node);
						}
					} else if (mainClass) {
						if (mainClass.main) {
							mainClass.main.call();
						} else if (mainClass.extendsClass(Face)) {
							this.document.body.appendChild(new mainClass().node);
						}
					}
				});
			});
		}
		
		function waitFor(event, callback) {
			if (this.addEventListener) {
				this.addEventListener(event, callback, false);
			} else if (this.attachEvent) {
				this.attachEvent("on"+event, callback);
			}
		}
		
		function loadback(source, callback) {
			var origin = _urlRE_.exec(source.base)[1];
			if (origin) {
				var action = (origin == $setting["baseOrigin"]) ? loadSameOrigin : loadCrossOrigin;
				action.call(this, source, callback);
			} else {
				throw Error("invalid URL: " + source.base);
			}
		}
		
		function loadSameOrigin(source, callback) {
			var caller = this;
			var request = requestSameOrigin(source, function() {
				if (!request || request.readyState != 4) return;
				if (request.status == 200 || request.status == 0) {
					source.content = request.responseText;
				} else {
					source.status = request.status;
					source.error = request.statusText;
				}
				callback.call(caller, source);
			});
			try {
				request.send(null);
			} catch (ex) {
				throw Error("failed to load URL: " + source.url + ", error: " + ex.message);
			}
		}
		
		function requestSameOrigin(source, callback) {
			var request;
			if (typeof XMLHttpRequest != "undefined" && typeof ActiveXObject == "undefined") {
				request = new XMLHttpRequest();
			} else if (typeof XMLHttpRequest != "undefined" && typeof ActiveXObject != "undefined" && $setting["baseScheme"] != "file") {
				request = new XMLHttpRequest();
			} else if (typeof ActiveXObject != "undefined") {
				request = new ActiveXObject("Microsoft.XMLHTTP");
			} else {
				throw Error("XHR not supported");
			}
			source.url = [source.base, source.module, source.path].join("/");
			request.open("GET", source.url, true);
			request.onreadystatechange = callback;
			return request;
		}
		
		function loadCrossOrigin(source, callback) {
			var caller = this;
			var request = requestCrossOrigin(source, function(response) {
				if (!request || !request.node) return;
				clearRequest(request);
				if (typeof response != "object") {
					source.error = "bad response";
				} else if (response.error) {
					source.error = response.error;
				} else {
					source.content = response.content;
				}
				callback.call(caller, source);
			});
		}
		
		function requestCrossOrigin(source, callback) {
			var request = {};
			request.url = source.url = [source.base, $setting["crossDomain"], source.module, source.path].join("/");
			this[$setting["bootModule"]][request.url] = callback;
			request.node = this.document.createElement("script");
			request.node.src = request.url;
			this.document.firstChild.firstChild.appendChild(request.node);
			request.interval = setInterval(callback, parseInt($setting["crossInterval"]));
			return request;
		}
		
		function clearRequest(request) {
			delete this[$setting["bootModule"]][request.url];
			this.document.firstChild.firstChild.removeChild(request.node);
			clearInterval(request.interval);
			delete request.node;
		}
		
		function resolvePath(path, base, isFolder) {
			if (!_urlRE_.exec(path)[1]) {
				if (path.charAt(0) == "/") {
					path = _urlRE_.exec(base)[1].concat(path);
				} else {
					base = isFolder ? base : splitPath(base, -1, -1);
					path = base ? base.concat("/", path) : path;
				}
			}
			return path;
		}
		
		function splitPath(path, index, count, delim) {
			if (!path) return path;
			delim = delim || "/";
			var parts = path.split(delim);
			index = index>=0 ? index : parts.length+index;
			var keep = count <= 0;
			count = keep ? -count : count;
			var parts2 = parts.splice(index, count);
			return (keep ? parts : parts2).join(delim);
		}
		
		main();
		
	})();
	
	function $static() {
		this.scope.$private = this.scope;
		with (this.scope.$static) {
			with (this.scope.$protected) {
				with (this.scope.$private) {
					try { eval(this.content); }
					finally { delete this.content; }
				}
			}
		}
	}
	
})();
