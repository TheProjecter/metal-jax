/**
 * @class metal.jax.Face
 * @imports System
 * 
 * @copyright Jay Tang 2012
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */

//@private
function initClass() {
	if (this.content) {
		this.$model = System.parseHTML(this.content);
		parseModel.call(this, this.$model);
		delete this.content;
	}
}

//@static
function parseModel(node, resolved) {
	for (var i = 0; i < node.childNodes.length; i++) {
		parseNode(node.childNodes[i], this, resolved);
	}
}

//@static
function initModel(node, args) {
	if (this.node) return;
	if ((!args || args.length == 0) && node) {
		this.node = node.cloneNode(true);
		initNode(this.node, this);
	} else if (args.length > 0) {
		this.node = args[0];
		var index = System.indexOfFirstChild(this.node);
		if (index >= 0) {
			initNode(this.node, this);
		} else if (node) {
			node = node.cloneNode(true);
			initNode(node, this);
			System.clearHTML(this.node);
			this.node.appendChild(node);
		}
	}
}

//@private
function parseNode(node, scope, resolved) {
	if (node.nodeType == 1) {
		if (!resolved) {
			if (node.nodeName.toLowerCase() == "img") {
				node.src = resolvePath(node.attributes["alt"].value||node.attributes["src"].value, scope);
				return;
			} else if (node.nodeName.toLowerCase() == "link") {
				System.docHead.appendChild(node);
				node.href = resolvePath(node.attributes["href"].value, scope);
				return;
			}
		}
		if (node.id) {
			var parts = node.id.split(":"), nodeId = parts.shift();
			var className = parts.join(":");
			var baseName = System.parseBaseName(className);
			if (className) {
				className = System.parseSourceName(className, scope.$static.getName(), $("faceType"));
				scope.$setting[baseName] = className;
				scope.$context.loadClass(className);
			}
		}
	}
	if (node.nodeType == 1 || node.nodeType == 11) {
		for (var i = 0; i < node.childNodes.length; i++) {
			parseNode(node.childNodes[i], scope, resolved);
		}
	}
}

//@private
function initNode(node, object) {
	if (node.nodeType == 1) {
		if (node.id) {
			var parts = node.id.split(":"), nodeId = parts.shift();
			var className = parts.join(":");
			var baseName = System.parseBaseName(className);
			
			object.nodes = object.nodes || {};
			object.nodes[nodeId] = node;
			className = className && object.getClass().$(baseName) || className;
			var childClass = object.getClass().getContext().findClass(className);
			if (node.title == nodeId) {
				var title = object.getClass().$(nodeId+".title");
				if (title) node.title = title;
			}
			if (childClass && childClass.extendsClass(Face)) {
				var index = System.indexOfFirstChild(node);
				if (index < 0) System.clearHTML(node);
				object.faces = object.faces || {};
				object.faces[nodeId] = new childClass(node);
				return;
			} else if (node.childNodes.length == 1 && node.firstChild.nodeType == 3 && node.innerHTML == nodeId) {
				var value = object.getClass().$(nodeId+".value");
				if (value) node.innerHTML = value;
				return;
			}
		}
	}
	if (node.nodeType == 1 || node.nodeType == 11) {
		for (var i = 0; i < node.childNodes.length; i++) {
			initNode(node.childNodes[i], object);
		}
	}
}

//@private
function resolvePath(path, scope) {
	var fromBase = path && path.indexOf("../") == 0;
	var sourceModule = scope.$static.$("module");
	var sourcePath = scope.$static.$("path");
	if (fromBase) {
		path = System.splitPath(path, 0, 1 - sourcePath.split("/").length);
	} else {
		path = System.resolvePath(path, sourcePath);
	}
	return System.resolvePath(path, sourceModule + "/");
}

//@private
var _events_ = [
	"keydown", "keypress", "keyup",
	"click", "dblclick",
	"mousedown", "mousemove", "mouseout", "mouseover", "mouseup"
];

//@public
function bind(action, node, event) {
	var binding = System.callback.call(this, dispatch, action, node);
	if (node && event) System.toggleEvent(event, node, binding);
	return binding;
}

//@private
function dispatch(action, node, event) {
	var status = action.call(this, node, event);
	if (status) return true;
	
	/*stop propagation*/
	if (event.stopPropagation) event.stopPropagation();
	event.cancelBubble = true;
	
	/*prevent default action in FF*/
	if (event.preventDefault) event.preventDefault();
	
	/*false to prevent default action in IE*/
	return false;
}
