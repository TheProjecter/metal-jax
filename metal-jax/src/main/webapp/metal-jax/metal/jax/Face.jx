/**
 * @class metal.jax.Face
 * @imports System
 * 
 * @copyright Jay Tang 2012
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */

//@private
function initClass() {
	if (this.content) {
		var node = System.parseHTML(this.content);
		this.$model = parseModel.call(this, node);
		delete this.content;
	}
}

//@static
function newObject(model) {
	var object = new this();
	initModel.call(object, model, false);
	return object;
}

//@static
function parseModel(node, resolved) {
	for (var i = 0; i < node.childNodes.length; i++) {
		parseNode(node.childNodes[i], this, resolved);
	}
	var index = System.indexOfFirstChild(node, true);
	if (index >= 0 && node.nodeType == 11) {
		node = node.childNodes[index];
	}
	return node;
}

//@static
function initModel(node, clone) {
	clone = clone || arguments.length == 1;
	this.node = clone ? node.cloneNode(true) : node;
	initNode(this.node, this);
}

//@private
function parseNode(node, scope, resolved) {
	if (node.nodeType == 1) {
		if (!resolved) {
			if (node.nodeName.toLowerCase() == "img") {
				node.src = resolvePath(node.attributes["alt"].value||node.attributes["src"].value, scope);
				return;
			} else if (node.nodeName.toLowerCase() == "link") {
				System.docHead.appendChild(node);
				node.href = resolvePath(node.attributes["href"].value, scope);
				return;
			}
		}
		if (node.id) {
			var parts = node.id.split(":");
			var nodeId = parts.shift(), className = parts.join(":");
			var baseName = System.parseBaseName(className);
			if (className) {
				className = System.parseSourceName(className, scope.$static.getName(), $("faceType"));
				scope.$setting[baseName] = className;
				scope.$context.loadClass(className);
			}
		}
	}
	if (node.nodeType == 1 || node.nodeType == 11) {
		for (var i = 0; i < node.childNodes.length; i++) {
			parseNode(node.childNodes[i], scope, resolved);
		}
	}
}

//@private
function initNode(node, object) {
	if (node.nodeType == 1) {
		if (node.id) {
			var parts = node.id.split(":");
			var nodeId = parts.shift(), className = parts.join(":");
			var baseName = System.parseBaseName(className);
			
			object.nodes = object.nodes || {};
			object.nodes[nodeId] = node;
			className = className && object.getClass().$(baseName) || className;
			var childClass = object.getClass().getContext().findClass(className);
			if (node.title == nodeId) {
				var title = object.getClass().$(nodeId+".title");
				if (title) node.title = title;
			}
			if (childClass && childClass.extendsClass(Face)) {
				var index = System.indexOfFirstChild(node);
				if (index >= 0) {
					childClass.newObject(node);
				} else {
					while (node.firstChild) node.removeChild(node.firstChild);
					node.appendChild(new childClass().node);
				}
				return;
			} else if (node.childNodes.length == 1 && node.firstChild.nodeType == 3 && node.innerHTML == nodeId) {
				var value = object.getClass().$(nodeId+".value");
				if (value) node.innerHTML = value;
				return;
			}
		}
	}
	if (node.nodeType == 1 || node.nodeType == 11) {
		for (var i = 0; i < node.childNodes.length; i++) {
			initNode(node.childNodes[i], object);
		}
	}
}

//@private
function resolvePath(path, scope) {
	var fromBase = path && path.indexOf("../") == 0;
	var sourceFolder = scope.$static.$("folder");
	var sourcePath = scope.$static.$("path");
	if (fromBase) {
		path = System.splitPath(path, 0, 1 - sourcePath.split("/").length);
	} else {
		path = System.resolvePath(path, sourcePath);
	}
	return System.resolvePath(path, sourceFolder, true);
}

//@private
var _events_ = [
	"keydown", "keypress", "keyup",
	"click", "dblclick",
	"mousedown", "mousemove", "mouseout", "mouseover", "mouseup"
];

//@public
function bind(action, node, event) {
	var binding = System.callback.call(this, dispatch, action, node);
	if (node && event) System.toggleEvent(event, node, binding);
	return binding;
}

//@private
function dispatch(action, node, event) {
	var status = action.call(this, node, event);
	if (status) return true;
	
	/*stop propagation*/
	if (event.stopPropagation) event.stopPropagation();
	event.cancelBubble = true;
	
	/*prevent default action in FF*/
	if (event.preventDefault) event.preventDefault();
	
	/*false to prevent default action in IE*/
	return false;
}
