/**
 * @class System
 * @imports Context
 * 
 * @copyright Jay Tang 2012
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */

//@private
function initClass() {
	System.window = window;
	System.document = window.document;
	System.docHead = window.document.firstChild.firstChild;
	Array.prototype.indexOf = Array.prototype.indexOf || indexOf;
	System.splitPath = Context.splitPath;
	System.resolvePath = Context.resolvePath;
	System.formatText = Context.formatText;
	System.parseBaseName = Context.parseBaseName;
	System.parseSourceName = Context.parseSourceName;
}

//@static
function callback() {
	var target = this, args = arguments;
	var action = Array.prototype.shift.call(arguments);
	var callback = (typeof action == "string") ? target[action] : action;
	if (callback) {
		return function() {
			Array.prototype.unshift.apply(arguments, args);
			return callback.apply(target === System ? this : target, arguments);
		};
	}
}

//@static
function indexOf(item, index) {
	index = index || 0;
	for ( ; index < this.length; index++) {
		if (index in this && this[index] === item) {
			return index;
		}
	};
	return -1;
}

//@static
function copyArray(items) {
	//return Array.prototype.slice.call(items, 0);
	var result = [];
	for (var i = 0; i < items.length; i++) result.push(items[i]);
	return result;
}

//@private
var _originRE_ = /^([^\/:]+:\/\/[^\/]*)/;

//@static
function loadback(source, callback) {
	var origin = _originRE_.exec(source.base)[1];
	if (origin) {
		var action = (origin == $("baseOrigin")) ? loadSameDomain : loadCrossDomain;
		action.call(this, source, callback);
	} else {
		throwError("invalid URL: ${0}", source.base);
	}
}

//@private
function loadSameDomain(source, callback) {
	var caller = this;
	var request = requestSameDomain(source, function() {
		if (!request || request.readyState != 4) return;
		try {
			if (request.status == 200 || request.status == 0) {
				source.content = (source.resourceType == "xml") ? request.responseXML.firstChild ?
					checkXML(request.responseXML) : parseXML(request.responseText) : request.responseText;
			} else {
				source.status = request.status;
				source.error = request.statusText;
			}
		} catch (ex) {
			source.error = ex.message;
		}
		callback.call(caller, source);
	});
	try {
		request.send(requestInput(source));
	} catch (ex) {
		throwError("failed to load URL: ${0}, error: ${1}", source.url, ex.message);
	}
}

//@private
function requestSameDomain(source, callback) {
	var request;
	if (typeof XMLHttpRequest != "undefined" && typeof ActiveXObject == "undefined") {
		request = new XMLHttpRequest();
	} else if (typeof XMLHttpRequest != "undefined" && typeof ActiveXObject != "undefined" && $("baseScheme") != "file") {
		request = new XMLHttpRequest();
	} else if (typeof ActiveXObject != "undefined") {
		request = new ActiveXObject("Microsoft.XMLHTTP");
	} else {
		throwError("XHR not supported");
	}
	var path = source.path.charAt(0) == "/" ? source.path : "/".concat(source.path);
	source.url = [source.base, source.module].join("/").concat(path);
	switch (requestMethod(source)) {
	case "GET":
		request.open("GET", requestURL(source), true);
		break;
	case "POST":
		request.open("POST", source.url, true);
		request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
		request.setRequestHeader("Content-Length", requestInput(source).length);
		break;
	}
	request.onreadystatechange = callback;
	return request;
}

//@private
function loadCrossDomain(source, callback) {
	var caller = this;
	var request = requestCrossDomain(source, function(response) {
		if (arguments.length == 0) return;
		clearRequest(request);
		if (typeof response != "object") {
			source.error = "bad response";
		} else if (response.error) {
			source.error = response.error;
		} else {
			try {
				source.content = (source.resourceType == "xml") ?
					parseXML(response.content) : response.content;
			} catch (ex) {
				source.error = ex.message;
			}
		}
		callback.call(caller, source);
	});
	System.docHead.appendChild(request.node);
}

//@private
function requestCrossDomain(source, callback) {
	var request = {};
	request.url = source.url = [source.base, $("crossDomain"), source.module, source.path].join("/");
	System.window[$("bootModule")][request.url] = callback;
	request.node = System.document.createElement("script");
	request.node.src = requestURL(source);
	request.timeout = setInterval(callback, parseInt($("crossTimeout")));
	return request;
}

//@private
function clearRequest(request) {
	delete System.window[$("bootModule")][request.url];
	System.docHead.removeChild(request.node);
	clearInterval(request.timeout);
	delete request.node;
}

//@private
function requestMethod(source) {
	return source.method && source.method.toUpperCase() == "POST" ? "POST" : "GET";
}

//@private
function requestInput(source) {
	return requestMethod(source) == "POST" ? (source.input||"") : null;
}

//@private
function requestURL(source) {
	return source.input ? source.url.concat("?", source.input) : source.url;
}

//@static
function parseValue(text, type) {
	switch (type) {
	case "boolean":
		return text == "true";
	case "date":
		return Date.parse(text);
	case "float":
		return parseFloat(text);
	case "integer":
		return parseInt(text);
	case "string":
	default:
		return text;
	}
}

//@private
var _lineRE_ = /(.*)(?:\r?\n)?/g;

//@static
function parseCSV(text, delimiter) {
	delimiter = delimiter || "\t";
	var result = [], match;
	while ((match = _lineRE_.exec(text)) && match[1]) {
		result.push(match[1].split(delimiter));
	}
	return result;
}

//@private
var _settingRE_= /\s*([\w.]+)\s*=\s*(.+)(?:\r?\n)?/g;

//@static
function parseProperties(text) {
	var result = {}, match;
	while ((match = _settingRE_.exec(text))) {
		result[match[1]] = match[2];
	}
	return result;
}

//@static
function parseJSONFromText(text) {
	return eval("(".concat(text, ")"));
}

//@private
var _spacesRE_ = /^\s*$/;

//@static
function parseJSONFromXML(node) {
	var result = {};
	for (var i = 0; i < node.childNodes.length; i++) {
		var childNode = node.childNodes[i];
		if (childNode.nodeType == 1) {
			result[childNode.nodeName] = parseJSONValueFromXML(childNode);
		}
	}
	return result;
}

//@private
function parseJSONValueFromXML(node) {
	var index = node.childNodes.length == 1 ? 0 : indexOfFirstChild(node, true);
	if (index >= 0) {
		node = node.childNodes[index];
		return (node.nodeType == 3) ? node.data : parseJSONFromXML(node);
	}
	var result = [];
	for (var i = 0; i < node.childNodes.length; i++) {
		var childNode = node.childNodes[i];
		if (childNode.nodeType == 1) {
			result.push(parseJSONFromXML(childNode));
		}
	}
	return result;
}

//@static
function indexOfFirstChild(node, only) {
	var index = -1;
	for (var i = 0; i < node.childNodes.length; i++) {
		if (node.childNodes[i].nodeType == 1) {
			if (!only) return i;
			if (index >= 0) return -1;
			index = i;
		}
	}
	return index;
}

//@static
function parseHTML(text) {
	var node = System.document.createElement("div");
	node.innerHTML = text;
	return moveHTML(node);
}

//@static
function moveHTML(node) {
	var doc = System.document.createDocumentFragment();
	while (node.firstChild) {
		doc.appendChild(node.firstChild);
	}
	return doc;
}

//@static
function clearHTML(node) {
	while (node.firstChild) node.removeChild(node.firstChild);
	return node;
}

//@static
function parseXML(text) {
	if (typeof DOMParser != "undefined") {
		return checkXML(new DOMParser().parseFromString(text, "text/xml"));
	} else if (typeof ActiveXObject != "undefined") {
		var doc = new ActiveXObject("Microsoft.XMLDOM");
		doc.async = false;
		doc.loadXML(text);
		return checkXML(doc);
	} else {
		throwError("XML parsing not supported");
	}
}

//@private
function checkXML(doc) {
	var content, error;
	if (doc.documentElement.nodeName == "parsererror") {
		error = doc.documentElement.childNodes[0].data;
		content = doc.documentElement.childNodes[1].childNodes[0].data;
		throwError("XML Error: ${0}, content: ${1}", error, content);
	} else if (doc.parseError && doc.parseError.errorCode) {
		error = doc.parseError;
		content = error.srcText;
		throwError("XML Error: ${0}, at line: ${1}, column: ${2}, content: ${3}",
				error.reason, error.line, error.linepos, content);
	}
	return doc;
}

//@static
function formatXML(doc) {
	if (typeof XMLSerializer != "undefined") {
		return new XMLSerializer().serializeToString(doc);
	} else if (typeof doc.xml != "undefined") {
		return doc.xml;
	} else {
		throwError("XML serialization not supported");
	}
}

//@static
function println(message, color) {
	var line = System.document.createElement("pre");
	line.style.margin = "0px";
	if (color) line.style.color = color;
	line.innerHTML = formatHTML(message);
	System.document.body.appendChild(line);
}

//@private
var _tagRE_ = /[<>]/g;

//@private
function formatHTML(message) {
	return message.toString().replace(_tagRE_, function(match) {
		switch (match) {
		case "<":
			return "&lt;";
		case ">":
			return "&gt;";
		default:
			return match;
		}
	});
}
