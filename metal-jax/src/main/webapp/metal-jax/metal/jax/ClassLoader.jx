//@ sourceURL=metal.jax.ClassLoader
/**
 * @copyright Jay Tang 2012
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
$public.getClass = function getClass() { return ClassLoader; };
$static.getSuperClass = function getSuperClass() { return Object; };
$static.getContext = function getContext() { return $context; };
$static.getName = function getName() { return "metal.jax.ClassLoader"; };
$static.$ = function $(name,value) { return name in $setting ? $setting[name] : value; };
$private.ClassLoader = function ClassLoader() {};
$imports.Context = "metal.jax.Context";
$imports.Object = "metal.jax.Object";
$imports.System = "metal.jax.System";

$private.initClass_ = function initClass_() {
	this.$source.baseName = "ClassLoader";
	this.$source.superBase = "Object";
	this.$source.$class = this.$source.scope[this.$source.baseName];
	this._callbacks = [];
	this._pendingCount = 0;
	this._pendingFlush = [];
	this._pendingFlush.push(this.$source);
	flush();
};

//calls each initObject in class hierarchy
$public.initObject = function initObject(clazz, args) {
	if (args.length == 1 && args[0] == clazz) return;
	if (clazz.getSuperClass()) {
		arguments.callee.call(this, clazz.getSuperClass(), args);
	}
	var source = getSource(clazz.getName(), clazz.getContext());
	if (source.scope.initObject) {
		source.scope.initObject.apply(this, args);
	}
};

//gets source holder of given context
$private.getHolder = function getHolder(context) {
	return $source.holder[context.getClass().getName()].holder;
};

//gets named source from given context
$private.getSource = function getSource(name, context) {
	return getHolder(context)[name];
};

//puts named source into source.context
$private.putSource = function putSource(source) {
	getHolder(source.context)[source.name] = source;
	if (source.contentType == "context") {
		$source.holder[source.name] = source;
	}
	return source;
};

//populates source object to be loaded
$private.initSource = function initSource(name, context) {
	name = parseSourceName(name);
	var setting = findSourceSetting(name, context);
	var nameOnly = parseSourceName(name, "", "");
	var source = {};
	source.name = name;
	source.type = parseSourceType(name);
	source.context = setting ? setting.context : context;
	source.base = setting ? setting.base : $("baseURL");
	source.module = setting ? setting.module : $("baseModule");
	source.path = nameOnly.split(".").join("/").concat(".", source.type);
	return source;
};

//finds named source in context hierarchy
$private.findSource = function findSource(name, context) {
	name = parseSourceName(name);
	var setting = findSourceSetting(name, context);
	return getSource(name, setting ? setting.context : context);
};

//finds source setting in context hierarchy
$private.findSourceSetting = function findSourceSetting(name, context) {
	while (true) {
		var settings = getSource(context.getClass().getName(), context).setting["source"];
		for (var i = 0; i < settings.length; i++) {
			var setting = settings[i];
			if (setting["includes"]) {
				if (setting["includes"].test(name)) {
					if (!(setting["excludes"] && setting["excludes"].test(name))) {
						return setting;
					}
				}
			} else if (setting["excludes"]) {
				if (!setting["excludes"].test(name)) {
					return setting;
				}
			}
		}
		var parent = context.getClass().getSuperClass().getContext();
		if (context == parent) break;
		context = parent;
	}
};

//finds content setting in context hierarchy
$private.findContentSetting = function findContentSetting(type, context) {
	while (true) {
		var settings = getSource(context.getClass().getName(), context).setting["content"];
		for (var i = 0; i < settings.length; i++) {
			var setting = settings[i];
			if (setting.type == type) {
				return setting;
			}
		}
		var parent = context.getClass().getSuperClass().getContext();
		if (context == parent) break;
		context = parent;
	}
};

//finds previously loaded class
$public.findClass = function findClass(name, positive) {
	if (!name) return;
	var source = findSource(name, this);
	if (source) {
		if (!source.error) {
			return source.$class;
		} else if (positive) {
			System.throwError("failed to load class: ${0}, error: ${1}", name, source.error);
		}
	}
};

//loads named class
$public.loadClass = function loadClass(name, callback) {
	try {
		if (!name || findSource(name, this)) return;
		_pendingCount++;
		var source = putSource(initSource(name, this));
		loadback(source, handleSource);
	} catch (ex) {
		_pendingCount--;
		source.error = ex.message;
		System.logError(ex);
	} finally {
		waitFor(callback);
	}
};

//calls back after pending class load
$private.waitFor = function waitFor(callback) {
	if (!callback) return;
	if (_pendingCount) {
		_callbacks.push(callback);
	} else {
		callback();
	}
};

//handles/flushes loaded source
$private.handleSource = function handleSource(source) {
	if (source.content) {
		try {
			parseSource(source);
		} catch (ex) {
			source.error = ex.message;
			System.logError(ex);
		}
	} else if (!source.error) {
		source.error = "empty content";
	}
	if (source.status < 100) {
		//error
	} else {
		_pendingCount--;
		flush();
	}
};

$private._classHeader_   = "//@ sourceURL=${0}\n";
$private._getClass_      = "$public.getClass = function getClass() { return ${0}; };\n";
$private._getSuperClass_ = "$static.getSuperClass = function getSuperClass() { return ${0}; };\n";
$private._getContext_    = "$static.getContext = function getContext() { return $context; };\n";
$private._getName_       = "$static.getName = function getName() { return \"${0}\"; };\n";
$private._getSetting0_   = "$static.$ = function $(name,value) { return name in $setting ? $setting[name] : value; };\n";
$private._getSetting1_   = "$static.$ = function $(name,value) { return name in $setting ? $setting[name] : $super.$static.$(name,value); };\n";
$private._getSetting2_   = "$static.$ = function $(name,value) { var v; return name in $setting ? $setting[name] : (v=$super.$static.$(name,value),v===value?$context.getClass().$(name,value):v); };\n";
$private._constructor_   = "$private.${0} = function ${0}() { $context.initObject.call(this, ${0}, arguments); };\n";
$private._initObject_    = "$private.initObject = function initObject() { initModel.call(this, $model, arguments); };\n";
$private._memberRE_      = /^\/\/@(\S+)\s+(function|var)\s+([A-Za-z0-9_$]+)/gm;
$private._classFooter_   = "\n//@ sourceURL=${0}\n";
//parses/compiles source setting
$private.parseSource = function parseSource(source) {
	parseModel(source);
	source.scope.$context = source.context;
	source.content = formatText(_classHeader_, source.name).concat(
		formatText(_getClass_, source.baseName),
		formatText(_getSuperClass_, source.superBase),
		_getContext_,
		formatText(_getName_, source.name),
		source.name == $imports.Object ? _getSetting0_ : source.contentType == "context" ? _getSetting1_ : _getSetting2_,
		formatText(_constructor_, source.baseName),
		source.type != $("classType") ? _initObject_ : "",
		source.content ? source.content.replace(_memberRE_, formatMember) : "",
		formatText(_classFooter_, source.name)
	);
	compile.call(source);
	_pendingFlush.push(source);
	source.$class = source.scope[source.baseName];
	source.context.loadClass(source.scope.$imports[source.superBase]);
	if (source.contentType != "context") {
		for (var name in source.scope.$imports) {
			source.context.loadClass(source.scope.$imports[name]);
		}
	}
};

$private._classHeaderRE_ = /^\s*\/\*\*([\S\s]*?)\*\//;
$private._classSettingRE_ = /@(setting|source|content)[\t ]+([\S\t ]*\S+)[\t ]*$|@([a-zA-Z]+)[\t ]+(\S+)[\t ]*([\S\t ]+)?[\t ]*$/gm;
//parses source header to collect source settings
$private.parseModel = function parseModel(source) {
	source.scope = { $public:{}, $protected:{}, $static:{}, $imports:{}, $setting:{} };
	source.scope.$setting.module = source.module;
	source.scope.$setting.path = source.path;
	if (source.type != $("classType")) {
		source.contentType = source.type;
		source.scope.content = source.content;
		source.content = null;
	} else {
		var match = _classHeaderRE_.exec(source.content);
		if (match) {
			source.content = source.content.substring(match[0].length);
			var header = match[1];
			while (match = _classSettingRE_.exec(header)) {
				var settingTag = match[1]||match[3], name = match[2]||match[4], value = match[5];
				if (!settingTag || !name) continue;
				switch (settingTag) {
				case "extends":
					name = parseSourceName(name, source.name);
					value = parseBaseName(name, value);
					source.scope.$imports[value] = name;
					source.superBase = source.superBase || value;
					break;
				case "imports":
					name = parseSourceName(name, source.name);
					value = parseBaseName(name, value);
					source.scope.$imports[value] = name;
					source.scope.$setting[value] = name;
					break;
				case "setting":
					parseSetting(source.scope.$setting, match);
					break;
				case "source":
				case "content":
					if (source.contentType == "context") {
						source.setting[settingTag].push(parseSetting({}, match));
					}
					break;
				case "class":
				case "context":
				default:
					if (source.contentType) break;
					source.contentType = settingTag;
					if (source.name != name) {
						System.throwError("incorrect ${0} name declared: ${1}", settingTag, name);
					}
					if (source.contentType == "context") {
						source.holder = {};
						source.setting = { source:[], content:[] };
					}
					break;
				}
			}
		}
	}
	source.contentType = source.contentType || "class";
	source.baseName = parseBaseName(source.name);
	if (!source.superBase && source.name != $imports.Object) {
		var setting = findContentSetting(source.contentType, source.context);
		var superName = setting && setting["extends"] || $imports.Object;
		source.superBase = parseBaseName(superName);
		source.scope.$imports[source.superBase] = superName;
	}
	if (!source.superBase || source.name == $imports.Object) {
		source.superBase = "null";
	}
};

$static.parseSourceName = function parseSourceName(name, base, type) {
	var parts; base = base || "";
	if (name.indexOf(".") < 0 && base.indexOf(".") > 0) {
		parts = base.split(".");
		parts[parts.length-1] = name;
		name = parts.join(".");
	}
	if (name.charAt(0) == ".") name = name.substring(1);
	parts = name.split(":");
	if (!parts[1] && name && type) {
		parts[1] = type;
		name = parts.join(":");
	}
	return (!parts[1] || parts[1] == $("classType") || type=="") ? parts[0] : name;
};

$private.parseSourceType = function parseSourceType(name) {
	var parts = name.split(":");
	return parts[1] || $("classType");
};

$static.parseBaseName = function parseBaseName(name, value) {
	value = value || splitPath(name, -1, 1, ".") || "";
	var parts = value.split(":");
	return (!parts[1] || parts[1] == $("classType")) ? parts[0] : parts.join("_");
};

$static.parsePackageName = function parsePackageName(name) {
	return splitPath(name, -1, -1, ".");
};

$private._settingRE_ = /([^=\t ]+)=(.+)/;
$private._settingsRE_ = /([^=\t ]+)=(\S+)/g;
//parses source setting
$private.parseSetting = function parseSetting(setting, match) {
	var input = match[0], settingTag = match[1], content = match[2], found;
	switch (settingTag) {
	case "setting":
		if (match = _settingRE_.exec(content)) {
			setting[match[1]] = match[2];
			found = true;
		}
		break;
	case "source":
	case "content":
		while (match = _settingsRE_.exec(content)) {
			setting[match[1]] = match[2];
			found = true;
		}
		break;
	}
	if (!found) {
		System.throwError("incorrect ${0} declared: ${1}", settingTag, input);
	}
	return setting;
};

$private._members_ = {
	"var": "$${0}.${2}",
	"function": "$${0}.${2} = ${1} ${2}"
};
//formats class members
$private.formatMember = function formatMember(match, memberTag, memberType, name) {
	return (memberType in _members_) ? formatText(_members_[memberType], memberTag, memberType, name) : match;
};

$private._NULL_ = {};
$private._formatRE_ = /\$\{([^\s\}:]+)(:[^\}]*)?\}/g;
//replaces macro references in text
$static.formatText = function formatText() {
	var args = arguments;
	var text = Array.prototype.shift.call(arguments);
	if (!text || text.indexOf("${") < 0) return text;
	var argType = typeof args[0];
	return text.replace(_formatRE_, function(match, name, value) {
		var result = _NULL_;
		if (argType != "object" && argType != "function" || args.length > 1) {
			var idx = parseInt(name);
			if (idx in args) return args[idx];
		} else if (argType == "object") {
			if (name in args[0]) return args[0][name];
		} else if (argType == "function") {
			result = args[0](name, _NULL_);
		}
		return result != _NULL_ ? result : value ? value.substring(1) : match;
	});
};

//flushes after all dependencies are loaded
$private.flush = function flush() {
	for (var i = 0; i < _pendingFlush.length; i++) {
		if (_pendingCount) return;
		flush_initClass(_pendingFlush[i]);
	}
	for (var i = 0; i < _pendingFlush.length; i++) {
		if (_pendingCount) return;
		flush_notifyClass(_pendingFlush[i]);
	}
	for (var i = 0; i < _pendingFlush.length; i++) {
		if (_pendingCount) return;
		flush_initContext(_pendingFlush[i]);
	}
	while (_callbacks.length) {
		if (_pendingCount) return;
		_callbacks.shift()();
	}
	for (var i = 0; i < _pendingFlush.length; i++) {
		if (_pendingCount) return;
		flush_notifyContext(_pendingFlush[i]);
	}
	for (var i = 0; i < _pendingFlush.length; ) {
		if (_pendingCount) return;
		if (_pendingFlush[i].flushStatus == 3) {
			_pendingFlush.splice(i, 1);
		} else i++;
	}
};

$private.flush_initClass = function flush_initClass(source) {
	if (typeof source.flushStatus == "undefined") {
		source.flushStatus = "busy 0";
		if (source.context) {
			source.scope[source.superBase] = source.context.findClass(source.scope.$imports[source.superBase], true);
			if (source.contentType != "context") {
				for (var name in source.scope.$imports) {
					source.scope[name] = source.context.findClass(source.scope.$imports[name], true);
				}
			}
		}
		var superSource;
		var superClass = source.scope[source.superBase];
		if (superClass) {
			var superName = source.scope.$imports[source.superBase];
			superSource = findSource(superName, source.context);
			flush_initClass(superSource);
		}
		if (source.contentType != "context") {
			for (var name in source.scope.$imports) {
				flush_initClass(findSource(source.scope.$imports[name], source.context));
			}
		}
		flush_initMember(source, superSource);
		if (source.contentType == "context") {
			for (var name in source.scope.$imports) {
				source.context.loadClass(source.scope.$imports[name]);
			}
		}
		source.flushStatus = 0;
		if (source.contentType != "context") {
			flush_notifyClass(source);
		}
	}
};

$private.flush_notifyClass = function flush_notifyClass(source) {
	if (source.flushStatus == 0) {
		source.flushStatus = "busy 1";
		if (source.contentType == "context") {
			for (var name in source.scope.$imports) {
				var clazz = source.scope[name] = source.context.findClass(source.scope.$imports[name], true);
				flush_notifyClass(getSource(clazz.getName(), clazz.getContext()));
			}
		}
		if (source.type != $("classType")) {
			var superName = source.scope.$imports[source.superBase];
			var superSource = findSource(superName, source.context);
			if (superSource.scope.initClass) {
				superSource.scope.initClass.call(source.scope);
			}
		} else {
			if (source.scope.initClass) {
				source.scope.initClass();
			}
		}
		source.flushStatus = 1;
	}
};

$private.flush_initContext = function flush_initContext(source) {
	if (source.flushStatus == 1) {
		source.flushStatus = "busy 2";
		for (var name in source.scope.$imports) {
			var clazz = source.scope[name];
			flush_initContext(getSource(clazz.getName(), clazz.getContext()));
		}
		if (source.contentType == "context" && source.scope.initObject) {
			source.scope.initObject.call(source.context);
		}
		source.flushStatus = 2;
	}
};

$private.flush_notifyContext = function flush_notifyContext(source) {
	if (source.flushStatus == 2) {
		source.flushStatus = "busy 3";
		for (var name in source.scope.$imports) {
			var clazz = source.scope[name];
			flush_notifyContext(getSource(clazz.getName(), clazz.getContext()));
		}
		if (source.contentType == "context" && source.scope.initContext) {
			source.scope.initContext.call(source.context);
		}
		source.flushStatus = 3;
	}
};

$private.flush_initMember = function flush_initMember(source, superSource) {
	if (superSource) {
		source.scope.$super = initMember({}, superSource.scope.$public);
		source.scope.$super.$static = initMember({}, superSource.scope.$static);
		source.scope.$super.$protected = initMember({}, superSource.scope.$protected);
		initMember(source.scope.$protected, source.scope.$super.$protected);
		initMember(source.scope.$static, source.scope.$super.$static);
		source.$class.prototype = new superSource.$class(superSource.$class);
		initMember(source.$class.prototype, source.scope.$super);
	}
	initMember(source.$class, source.scope.$static);
	initMember(source.$class.prototype, source.scope.$public, true);
	initMember(source.scope.$public, source.scope.$super);
	if (source.contentType == "context") {
		source.context = source.scope.$context = new source.$class(source.$class);
		putSource(source);
	}
	flush_initSetting(source);
};

$private.flush_initSetting = function flush_initSetting(source) {
	initSetting(source.scope.$setting, source.$class);
	if (source.contentType == "context") {
		var settings = source.setting["source"];
		for (var i = 0; i < settings.length; i++) {
			var setting = settings[i];
			initSetting(setting, source.$class);
			if (setting["includes"]) {
				setting["includes"] = new RegExp(setting["includes"]);
			}
			if (setting["excludes"]) {
				setting["excludes"] = new RegExp(setting["excludes"]);
			}
			setting.context = source.context;
		}
		var settings = source.setting["content"];
		for (var i = 0; i < settings.length; i++) {
			var setting = settings[i];
			initSetting(setting, source.$class);
			setting.context = source.context;
		}
	}
};

//copies source members to target
$private.initMember = function initMember(target, source, override) {
	if (source && target) {
		for (var name in source) {
			switch (name) {
			case "$private":
			case "$static":
			case "$public":
			case "$protected":
			case "$super":
				continue;
			}
			if (override) {
				target[name] = source[name];
			} else {
				target[name] = target[name] || source[name];
			}
		}
	}
	return target;
};

//normalizes setting values
$private.initSetting = function initSetting(setting, clazz) {
	if (setting) {
		for (var name in setting) {
			setting[name] = formatText(setting[name], clazz.$);
		}
	}
};

//@ sourceURL=metal.jax.ClassLoader
