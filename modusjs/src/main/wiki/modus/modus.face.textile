<link type="text/css" rel="stylesheet" href="../styles/main.css"/>

p(title). Package @modus.face@

{toc:style=decimal}

h1. Overview

Contains classes for implementing features of Modus Face UI framework.

h1. Summary

Modus Face UI framework provides a small set of modifiers and markings in HTML content to build and refine HTML based UI.

Modus follows the MVC pattern with all client-side components, represented with HTML, JavaScript, and CSS artifacts.

h1. Details

h2. Modifiers and Markings

Modus Face applies modifier markings to HTML syntax to incrementally introduce UI features:
# view/controller
# placeholder/part
# scope
# json
# binding
# macro


h2. View

Modus structures HTML artifacts into template files called views.

Sometimes logical fragments of HTML content are repeated in UI. Such fragments can be extracted as template files. Modus Face calls these fragments "views", and provides modifier view to inject the content.

UI visual elements can be abstracted and partitioned into logical structures called _Views_, and optionally with view content in separate HTML fragment files, identified with qualified resource names. View makes UI components modular and reusable.

View may have internal substructures, declared with modifier markings inside HTML element @class@ attribute.

Steps to initialize view:
# scan view content for modifier markings/macros, normalize external view contents at the same time.
# normalize placeholders
# ----
# normalize scope content
# bind events/inputs to actions
# normalize templates/inputs

Steps to update view:
# normalize scope content
# bind events/inputs to actions
# normalize templates/inputs

h3. Inline/External

View is declared by modifier @view@. View content can be either inline or external, with inline as default.

For external content the modifier format is @view:name@. Modus will resolve external contents and include them into UI at runtime.

h3. Placeholder/Part

View supports static template with placeholders, where placeholder are template openings that can be later filled by part with the same name at runtime.

Placeholder is declared by modifier @placeholder:name@, and part declared by @part:name@. Name is only necessary for multiple placeholders.

Placeholders are resolved/replaced after external view contents are resolved.

h3. Macro/Scope/Bean

View also supports dynamic template with macros in attributes and texts. Macros are resolved/replaced by view or bean attributes. For macros that resolve against bean attributes, the containing element is scoped by the bean name by modifier @scope:name@. Without the modifier, macros are resolved against view attributes directly.

Order of resolution for macro is bean, view, controller.

Macro replacements can be refreshed when view/bean attributes changed.

h3. repeat modifier

If for bean that is an array, a referencing scope can be marked as @repeat@. So the scoped element content will repeat for each array item, or be blank for empty array.

Repeat elements can be added/removed when bean array items are added/removed.

h3. Event Binding

Binding can be declared by modifier @event:action@, action is resolved to be a controller method.

h3. Input Value

Initial values for input elements default to macros with the same name, scoped by view or bean.

h3. Input Event

Input elements by default imply a change event binding as @change:change@.

h2. Controller

Modus structures JS artifacts into modus classes, called controllers, extending from a base class @modus.face.Controller@.

Controller provides two kinds of callback methods:
# static methods are called to notify view init events.
# public methods are callback methods that macro names and binding actions resolve to.

h2. Notes

h3. Scope and Repeat Modifiers

Scope modifier fine tunes resolution context to a view property bean. Repeat modifier does the same to a bean array element.

h3. Inline JSON

By default, properties of an inline JSON instance are installed as properties of the containing view. However with a scope modifier, the JSON instance itself will be installed as a view property with the modifier name.

h3. Template Macro

Macro names are resolved as properties/methods in the order of bean identified by scope modifier, view or controller.

h3. Binding Action

Actions are resolved as controller methods. Actions return true to trigger a refresh in the view top scope, or just scopes identified by a scope modifier.

h3. Input Element

Input elements serve as both a template macro and binding with default action.
